# `art_modern`: Modernized ART Simulator of Diverse Next-Generation Sequencing Reads

`art_modern` badges:
[![GitHub Release](https://img.shields.io/github/v/release/YU-Zhejian/art_modern.svg)](https://github.com/YU-Zhejian/art_modern/releases)
[![GitHub Downloads](https://img.shields.io/github/downloads/YU-Zhejian/art_modern/total.svg?style=social&logo=github&label=Download)](https://github.com/YU-Zhejian/art_modern/releases/)
[![License](https://img.shields.io/badge/licence-GPL_3.0-blue.svg)](https://www.gnu.org/licenses/)
[![Code style: black](https://img.shields.io/badge/code%20style-webkit-blue.svg)](https://webkit.org/code-style-guidelines/)

`art_modern` on BioConda: [![Install with BioConda](https://img.shields.io/badge/install%20with-bioconda-brightgreen.svg)](http://bioconda.github.io/recipes/art_modern/README.html)
[![Conda Version](https://img.shields.io/conda/vn/bioconda/art_modern)](https://anaconda.org/bioconda/art_modern)
[![Conda Downloads](https://img.shields.io/conda/dn/bioconda/art_modern)](https://anaconda.org/bioconda/art_modern)

`art_modern-openmpi` on BioConda: [![Install with BioConda](https://img.shields.io/badge/install%20with-bioconda-brightgreen.svg)](http://bioconda.github.io/recipes/art_modern-openmpi/README.html)
[![Conda Version](https://img.shields.io/conda/vn/bioconda/art_modern-openmpi)](https://anaconda.org/bioconda/art_modern-openmpi)
[![Conda Downloads](https://img.shields.io/conda/dn/bioconda/art_modern-openmpi)](https://anaconda.org/bioconda/art_modern-openmpi)

`art-modern-utils` badges:
[![GitHub Release](https://img.shields.io/github/v/release/YU-Zhejian/art_modern_utils.svg)](https://github.com/YU-Zhejian/art_modern_utils/releases)
[![GitHub Downloads](https://img.shields.io/github/downloads/YU-Zhejian/art_modern_utils/total.svg?style=social&logo=github&label=Download)](https://github.com/YU-Zhejian/art_modern_utils/releases)
[![License](https://img.shields.io/badge/licence-GPL_3.0-blue.svg)](https://www.gnu.org/licenses/)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)

`art-modern-utils` on PyPI:
[![Python version](https://img.shields.io/badge/python-3.9-blue)](https://www.python.org/downloads/)
[![PyPI - Version](https://img.shields.io/pypi/v/art-modern-utils)](https://pypi.org/project/art-modern-utils/)
[![PyPI - Downloads](https://img.shields.io/pypi/dm/art-modern-utils)](https://pypi.org/project/art-modern-utils/)

[![Catalogued on GSR](https://surveillance.cancer.gov/gsr/static/img/gsr_tile.jpg)](https://surveillance.cancer.gov/genetic-simulation-resources/packages/art_modern/)

## Introduction

Here we introduce `art_modern`, a modern re-implementation of the popular [ART](https://www.niehs.nih.gov/research/resources/software/biostatistics/art) simulator with enhanced performance and functionality. It can be used for anyone who wants to simulate sequencing data for their own research, like benchmarking of DNA- or RNA-Seq alignment algorithms, test whether the RNA-Seq pipeline built by your lab performs well or perform pressure testing of pipelines on a cluster.

`art_modern` supports ART-compatible error profiles. We also implemented a high-performance profile creator that creates ART-compatible profiles out of FASTQ, SAM, and BAM files.

## Quick Start

### Installation

**NOTE** Although we're providing compiled binaries for Linux, we still recommend compiling the source code yourself for maximum performance.

#### Using Fully Static Build

In each release, there will be a file named `build_rel_with_dbg_alpine-x86_64.tar.gz` in the [Releases](https://github.com/YU-Zhejian/art_modern/releases) section. The file contains fully static linked libraries and executable binaries built under x86\_64 Alpine Linux, which should work on most x86\_64 Linux distributions. Unzip it, and you're good to go.

**WARNING** Static builds may lead to compromised security.

**NOTE** The fully static build supports **NEITHER** MPI **NOR** NCBI SRA files.

#### Using `dpkg`

If you use specific versions of Debian or Ubuntu, you can install `art_modern` through pre-built DEB packages available with each release. Root privileges are required.

**NOTE** The DEB build does **NOT** support NCBI SRA files.

#### Using Docker/Podman/Singularity

The Docker/Podman/Singularity containers generated by BioConda is available at [Quay.io](https://quay.io/repository/biocontainers/art_modern) ([MPI-enabled version](https://quay.io/repository/biocontainers/art_modern-openmpi)).

A singularity example is provided below:

```shell
singularity pull --name art_modern-1.3.2.sif docker://quay.io/biocontainers/art_modern:1.3.2--hb45bfb9_0
singularity run art_modern-1.3.2.sif art_modern --version
```

#### Using Conda

[Conda](https://docs.conda.io/) (or [Mamba](https://mamba.readthedocs.io/en/latest/)/[micromamba](https://mamba.readthedocs.io/en/latest/user_guide/micromamba.html)) is a popular open-source package and environment management system that simplifies the installation and management of software packages and their dependencies. Before processing, make sure you've installed Conda >=25.7.0 by `conda --version`. Then, to create an environment named `art_modern_bioconda` with the package installed:

```shell
conda create -y -n art_modern_bioconda -c bioconda -c conda-forge art_modern
conda run --no-capture-output --live-stream -n art_modern_bioconda art_modern --version
```

Or, use `art_modern-openmpi` to install the MPI-enabled version.

**NOTE** The Conda build does **NOT** support NCBI SRA files.

#### Compiling the Source Code

Use [Git](https://git-scm.com/) to clone this repository:

```shell
git clone -b master https://github.com/YU-Zhejian/art_modern.git
cd art_modern
```

Or, if you have no Git:

```shell
curl -L -o art_modern-master.zip \
    https://github.com/YU-Zhejian/art_modern/archive/refs/heads/master.zip
# -L used to make cURL following redirects
unzip art_modern-master.zip
cd art_modern-master
```

**STRONGLY DISCOURAGED** Change `master` to `devel` to compile the development version

Ensure you have a C++ compiler that supports [C++17](https://en.cppreference.com/w/cpp/17) installed on your computer (Preferably [GCC](https://gcc.gnu.org/) >= 9.5.0). Also check whether your [CMake](https://cmake.org/), [GNU Make](https://www.gnu.org/software/make/), [Boost C++ Library](https://www.boost.org/), [GNU BinUtils](https://www.gnu.org/software/binutils/), [GNU Bash](https://www.gnu.org/software/bash/), [GNU CoreUtils](https://www.gnu.org/software/coreutils/), [Python 3](https://www.python.org/), and minimal HTSLib dependencies (namely, [zlib](https://www.zlib.net/) and [pthread](https://www.man7.org/linux/man-pages/man7/pthreads.7.html)) are working.

Build the project using:

```shell
mkdir -p opt/build_release
env -C opt/build_release cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo "$(pwd)"
cmake --build opt/build_release -j"$(nproc)"
```

The project binary will be available at `opt/build_release/art_modern`. Now we can test whether the program runs through:

```shell
opt/build_release/art_modern --help
opt/build_release/art_modern --version
```

### Simulating WGS Data using _E. Coli_ Genome

Download _E. coli_ reference genome from NCBI. Here, we'll use the K-12 strand MG1655 sub-strand as an example.

```shell
mkdir -p opt/data/
ACCESSION="GCF_000005845.2_ASM584v2"
BASEURL="https://ftp.ncbi.nlm.nih.gov/genomes/all"
wget -O opt/data/GCF_000005845.2_ASM584v2_genomic.fna.gz -4 \
    "${BASEURL}"/GCF/000/005/845/"${ACCESSION}"/"${ACCESSION}"_genomic.fna.gz \
    
gunzip -n -k opt/data/GCF_000005845.2_ASM584v2_genomic.fna.gz
# -n used to supress restoration of original timestamp.
```

Now we can simulate WGS data using _E. coli_ reference genome. Let's start with single-end sequencing using HiSeq 2500 (which is the default `art_modern` profile and can be set explicitly through `--builtin_qual_file HiSeq2500_150bp`) with 250 bp read length (which is the longest read lengths supported by the profile and can be set explicitly through `--read_len 250`), 10X coverage, and all available threads (can be set explicitly through `--parallel`).

```shell
opt/build_release/art_modern \
    --mode wgs \
    --lc se \
    --i-file opt/data/GCF_000005845.2_ASM584v2_genomic.fna \
    --o-fastq opt/build_release/e_coli_wgs_se.fastq \
    --i-fcov 10
```

The generated FASTQ file will be at `opt/build_release/e_coli_wgs_se.fastq`.

We may also simulate paired-end data with the following configuration:

```shell
opt/build_release/art_modern \
    --mode wgs \
    --lc pe \
    --i-file opt/data/GCF_000005845.2_ASM584v2_genomic.fna \
    --o-fastq opt/build_release/e_coli_wgs_pe.fastq \
    --i-fcov 10 \
    --pe_frag_dist_mean 300 \
    --pe_frag_dist_std_dev 50
```

Please note that we have additionally specified a quality file for read 2 with the mean and standard deviation of fragment lengths, which are required for paired-end sequencing. The generated fragment length should follow a normal (Gaussian) distribution with desired mean and standard deviation.

**NOTE** The generated FASTQ file needed to be split into two FASTQ files and sorted for most pipelines. See [this section in the FAQ](#fastq-split-section) for more details.

### Simulating RNA-Seq Data using _C. Elegans_ Transcriptome

Simulating transcriptome is a little more complicated since each cDNA molecule has different counts. Strand-specific library technologies also generate RNA-Seq data on one strand only. You're recommended to use [YASIM](https://pypi.org/project/YASIM) or other high-level simulators to generate expression for each cDNA molecule. You can also convert transcript quantification results generated by [featureCounts](https://subread.sourceforge.net/featureCounts.html), [htseq-count](https://htseq.readthedocs.io/en/latest/), [Salmon](https://salmon.readthedocs.io/en/latest/), [Kallisto](https://pachterlab.github.io/kallisto/) or [STAR](https://github.com/alexdobin/STAR) to the format supported by `art_modern`. The unified coverage model (i.e., like WGS) is also supported.

Please note that cDNAs with insufficient length will be ignored. We also do not support circular RNA simulation.

#### Unified Coverage

Following example samples 1000 long transcripts from reference _C. Elegans_ transcriptome from [UCSC Genome Browser](https://genome.ucsc.edu/) and performs a simulation using 10X unified coverage. You need to install [seqtk](https://github.com/lh3/seqtk) and [seqkit](https://bioinf.shenwei.me/seqkit) to run this example:

```shell
curl https://hgdownload.soe.ucsc.edu/goldenPath/ce11/bigZips/mrna.fa.gz | \
    gzip -cdf | \
    seqkit seq -m 200 | \
    seqtk sample /dev/stdin 1000 > opt/build_release/ce11_mrna_1000.fa

opt/build_release/art_modern \
    --mode trans \
    --lc se \
    --i-file opt/build_release/ce11_mrna_1000.fa \
    --o-fastq opt/build_release/c_elegans_trans_unified_se.fastq \
    --i-fcov 10
```

#### Unstranded Coverage

To simulate data with unstranded coverage information (i.e., same coverage on both strands), you need to provide an additional TSV file with one column of transcript ID and another column of coverage (in floating points). Please note that lines started by `#` will be ignored. An example of the coverage file (Depth rounded to 2 decimal for simplicity):

```text
NM_069135	6.69
NR_056112	5.19
NR_051843	3.45
NR_066512	4.73
```

The following example generates a coverage file using [GNU AWK](https://www.gnu.org/software/gawk/) with random coverage ranging between 0 and 10 assigned to each cDNA molecule.

```shell
samtools faidx opt/build_release/ce11_mrna_1000.fa
awk 'BEGIN{print "#ID\tCOV";}{printf "%s\t%f\n", $1, (rand()*10);}' \
    < opt/build_release/ce11_mrna_1000.fa.fai \
    > opt/build_release/ce11_mrna_1000.fa.unstranded_cov.tsv

opt/build_release/art_modern \
    --mode trans \
    --lc se \
    --i-file opt/build_release/ce11_mrna_1000.fa \
    --o-fastq opt/build_release/c_elegans_trans_unstranded_se.fastq \
    --i-fcov opt/build_release/ce11_mrna_1000.fa.unstranded_cov.tsv
```

#### Stranded Coverage

To simulate data with stranded coverage information (i.e., coverage on one strand is different from the other), you need to provide an additional TSV file with one column of transcript ID and two other columns of coverage in positive and negative strand (in floating points). An example of the coverage file:

```text
NM_069135	2.31	4.38
NR_056112	3.47	1.72
NR_051843	1.35	2.09
NR_066512	3.04	1.68
```

Code example:

```shell
awk 'BEGIN{print "#ID\tCOV_POS\tCOV_NEG";}{printf "%s\t%f\t%f\n", $1, (rand()*5), (rand()*5);}' \
    < opt/build_release/ce11_mrna_1000.fa.fai \
    > opt/build_release/ce11_mrna_1000.fa.stranded_cov.tsv

opt/build_release/art_modern \
    --mode trans \
    --lc se \
    --i-file opt/build_release/ce11_mrna_1000.fa \
    --o-fastq opt/build_release/c_elegans_trans_stranded_se.fastq \
    --i-fcov opt/build_release/ce11_mrna_1000.fa.stranded_cov.tsv
```

#### The PBSIM3 Transcripts Input Format

The PBSIM3 Transcripts input format is a 4-column tab-delimited text file with transcript ID, sequence, and coverage on both strands. This file includes both sequence and coverage, so no additional coverage parameter is required. Similarly, sequences with insufficient length and lines started with `#` will be ignored. An example of the transcript input file is as follows (Sequences represented as `aaaa`):

```text
NR_056112	3.47	1.72	aaaa
NR_051843	1.35	2.09	aaaa
NR_066512	3.04	1.68	aaaa
NM_061905	0.96	1.39	aaaa
NR_054174	3.59	4.92	aaaa
```

The following example converts the FASTA file to the PBSIM3 Transcripts input format with the help of [seqkit](https://bioinf.shenwei.me/seqkit) with random coverage generated using GNU AWK. Note that the `--i-type` parameter is required.

```shell
seqkit fx2tab opt/build_release/ce11_mrna_1000.fa | \
    awk 'BEGIN{print "#ID\tCOV_POS\tCOV_NEG\tSEQ";}{printf "%s\t%f\t%f\t%s\n", $1, (rand()*5), (rand()*5), $3;}' \
    > opt/build_release/ce11_mrna_1000.fa.pbsim3_trans.tsv

opt/build_release/art_modern \
    --mode trans \
    --lc se \
    --i-file opt/build_release/ce11_mrna_1000.fa.pbsim3_trans.tsv \
    --o-fastq opt/build_release/c_elegans_trans_pbsim3_se.fastq \
    --i-type pbsim3_transcripts
```

### Template-Based Simulation

Template-based simulation is often used to introduce Illumina specific errors to cDNA molecules generated from some upstream simulator like [CAMPAREE](https://camparee.readthedocs.io/en/latest/). In this mode, single-end reads will be started from the first base of the template while paired-end/mate-pair reads will span the entire template. The template-based simulation mode also supports the PBSIM3 Transcripts format. For example:

```shell
opt/build_release/art_modern \
   --mode template \
   --lc pe \
   --i-file opt/build_release/ce11_mrna_1000.fa.pbsim3_trans.tsv \
   --o-fastq opt/build_release/c_elegans_template_pbsim3_se.fastq \
   --i-type pbsim3_transcripts
```

Please note that the mean and standard deviation of fragment length is not specified since in template-based simulation, a template is considered a fragment.

**NOTE** For coverage of the template mode:

- If a unified coverage file is provided, the coverage will be interpreted as positive coverage instead of being divided equally into both strands.
- If a 2-column (unstranded) coverage file is provided, the coverage will be interpreted as positive coverage.
- If a 3-column (stranded) coverage file or input in format of `pvsim3_transcripts` is provided, the coverage will be interpreted as-is.

## Advanced Topics

### Using UNIX Pipelines

With UNIX pipelines, we can redirect the input and output of `art_modern` from/to another file/processes. Following example reads FASTA reference from `/dev/stdin` (Standard Input), and writes compressed FASTQ, FASTA, and sorted BAM files.

This example requires [gzip](https://www.gnu.org/software/gzip/), [pigz](https://zlib.net/pigz/), [SAMtools](https://github.com/samtools/samtools), and [XZ Utils](https://tukaani.org/xz/). Note that the `--i-type` parameter is required since now, the simulator cannot tell the file format through its file extension.

```shell
zcat opt/data/GCF_000005845.2_ASM584v2_genomic.fna.gz | \
    opt/build_release/art_modern \
    --mode wgs \
    --lc se \
    --i-file /dev/stdin \
    --i-type fasta \
    --i-parser memory \
    --o-fastq >(pigz -9-cf - > opt/build_release/e_coli_wgs_se.fastq.gz) \
    --o-fasta >(xz -9 -T5 -cf - > opt/build_release/e_coli_wgs_se.fasta.xz) \
    --o-sam >(samtools sort -o opt/build_release/e_coli_wgs_se.sorted.bam) \
    --i-fcov 5
```

Please wait for a while for the compression to finish.

**NOTE** Pipelines and redirections are not supported in MPI mode mentioned below.

### Using MPI

Message Passing Interface ([MPI](https://www.mpi-forum.org/)) is a standard for parallel computing on a high-performance cluster (HPC). It allows processes to communicate with each other through intranet. If you're working on a cluster with MPI installed, you can use the MPI version of `art_modern` to speed up the simulation by executing `art_modern` on different nodes in parallel.

**NOTE** Please consult your cluster administrator/cluster documentation before using MPI version, since some clusters may have special configurations and/or quota limitations.

See also:

- [Documentation for MPI Integration in Slurm](https://slurm.schedmd.com/mpi_guide.html) if your cluster uses [Slurm Workload Manager](https://slurm.schedmd.com/).

Documentations from MPI vendors:

- [Open MPI Documentation](https://www.open-mpi.org/doc/), especially [Launching MPI applications](https://docs.open-mpi.org/en/v5.0.x/launching-apps/index.html) section.
- [MPICH Documentation](https://www.mpich.org/documentation/).
- [Intel MPI Documentation](https://www.intel.com/content/www/us/en/developer/tools/oneapi/mpi-library.html?wapkw=MPI).

You may also find the following information helpful:

- [OpenHPC Community](https://openhpc.community/) if you'd like to build your own HPC cluster.

#### Building MPI-Enabled `art_modern`

Load the MPI environment on your cluster. Then execute:

```shell
mkdir -p opt/build_release-mpi
env -C opt/build_release-mpi \
    cmake \
    -DCMAKE_BUILD_TYPE=RelWithDebInfo \
    -DWITH_MPI=ON \
    "$(pwd)"
cmake --build opt/build_release-mpi -j"$(nproc)"
```

Test whether the MPI version works:

```shell
mpiexec -n 1 opt/build_release-mpi/art_modern-mpi --version
```

You should be able to see the output MPI standard version and vendor-specific information. For example:

```text
MPI:
        Standard Version: 3.1
        Library Version: Open MPI v4.1.6, [...]
```

If you're using OpenMPI.

#### Changes in Output Files

Let us run a WGS simulation with 4 MPI processes:

```shell
mpiexec -n 4 opt/build_release-mpi/art_modern-mpi \
    --mode wgs \
    --lc se \
    --i-file opt/data/GCF_000005845.2_ASM584v2_genomic.fna \
    --o-fastq opt/build_release-mpi/e_coli_wgs_se.fastq \
    --i-fcov 20 \
    --parallel 4
```

4 files, namely `e_coli_wgs_se.0.fastq`, `e_coli_wgs_se.1.fastq`, `e_coli_wgs_se.2.fastq`, and `e_coli_wgs_se.3.fastq` will be generated in `opt/build_release-mpi/` directory. Each file corresponds to the output from each MPI process (rank 0 to rank 3). This behavior is the same for other output files (e.g., PWA, SAM/BAM).

**NOTE** In the above example, the actual number of computational threads used in simulation will be 16 (4 MPI processes * 4 threads per process) since we've specified `--parallel 4`.

#### Other Differences Between MPI and Non-MPI Versions

- The simulator will not be able to support UNIX devices and/or redirections for input/output files. So, even if your input is enormous, you have to write it to a physical file first. However, as most HPC clusters use distributed file systems, this should not be a big problem.
- Logging issues: Only log messages from rank 0 process will be printed to standard error. Other ranks' log messages will be written to disk (If environment variable `ART_NO_LOG_DIR` is not set) or discarded (If environment variable `ART_NO_LOG_DIR` is set).

## Building ART/`art_modern` Profiles

The `art_profile_builder` is a new executable designed to replace the old art_profiler_illumina Shell/Perl scripts for building ART-compatible quality profiles. It supports input from FASTQ, SAM/BAM, and NCBI SRA (If configured) files. The generated files would be compatible with the original ART and `art_modern`.

Examples using single-end FASTQ:

```bash
art_profile_builder \
    --i-file input.fq \
    --read_len 36 \
    --o-file1 output_profile.txt \
    --parallel 8 \
    --i-num_threads 4
```

Examples using paired-end SAM/BAM:

```bash
art_profile_builder \
    --i-file input.sam \
    --read_len 36 \
    --is_pe \
    --o-file1 output_R1.txt \
    --o-file2 output_R2.txt \
    --parallel 10 \
    --i-num_threads 4
```

For complete usage information, see the [full documentation](#art_profile_builder-usage-section).

By default, the program would **NOT** support building profiles from NCBI short-read archive (SRA). Use `-DWITH_NCBI_NGS=ON` to enable it. Additional libraries are required. See [this section in Installation instruction](#optional-ncbi-ngs-components) for details.

## What's Next?

The project provides diverse documentations to satisfy your needs.

- If you want to build the software with different options, see [Install](docs/Install.md).
- For a detailed guide on parameters and their combinations, see [Usage for `art_modern`](docs/Usage-art_modern.md), [Usage for `art_profile_builder`](docs/Usage-apb.md) and [FAQ](docs/FAQ.md).
- For developers, please refer to:
  - [Contributing](docs/Contributing.md) for software engineering tasks and contribution guidelines. See also [Code of Conduct](docs/CODE_OF_CONDUCT.md).
  - [Design](docs/Design.md) for the latest design of the software.
  - [Copying](docs/Copying.md) for third-party libraries and codes used in this project.
  - [News](docs/News.md) for changes over the project.
- For a comparison of this project with other simulators, see [Benchmark](https://github.com/YU-Zhejian/art_modern_benchmark_other_simulators).
- The original ART documentation is copied to [here](https://github.com/YU-Zhejian/art_modern/tree/master/docs/original_art_docs).

## Acknowledgements

This simulator is based on the works of [Weichun Huang](mailto:whduke@gmail.com) _et al._, under [GNU GPL v3](https://www.gnu.org/licenses/) license. The software is originally distributed [here](https://www.niehs.nih.gov/research/resources/software/biostatistics/art) with the following reference:

- W. Huang, L. Li, J. R. Myers, and G. T. Marth, _ART: a next-generation sequencing read simulator_, Bioinformatics (Oxford, England), vol. 28, no. 4, pp. 593--594, Feb. 2012, DOI: [10.1093/bioinformatics/btr708](https://doi.org/10.1093/bioinformatics/btr708).

Bundled libraries in this project are distributed under their own licenses. See [Copying](docs/Copying.md) for details.
